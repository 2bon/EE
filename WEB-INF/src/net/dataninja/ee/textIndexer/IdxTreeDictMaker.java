package net.dataninja.ee.textIndexer;


/**
dataninja copyright statement
 */
import java.io.File;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.spelt.SpellWriter;
import org.apache.lucene.util.ProgressTracker;
import net.dataninja.ee.util.Path;
import net.dataninja.ee.util.Trace;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/**
 * This class provides a simple mechanism for generating a spelling correction
 * dictionary after new documents have been added or updated. <br><br>
 *
 * To use this class, simply instantiate a copy, and call the
 * {@link IdxTreeDictMaker#processDir(File) processDir()}
 * method on a directory containing an index. Note that the directory passed
 * may also be a root directory with many index sub-directories if desired.
 */
public class IdxTreeDictMaker 
{
  ////////////////////////////////////////////////////////////////////////////

  /**
   * Create an <code>IdxTreeDictMaker</code> instance and call this method to
   * create spelling dictionaries for one or more Lucene indices. <br><br>
   *
   * @param  dir         The index database directory to scan. May be a
   *                     directory containing a single index, or the root
   *                     directory of a tree containing multiple indices.
   *                     <br><br>
   *
   * @.notes             This method also calls itself recursively to process
   *                     potential index sub-directories below the passed
   *                     directory.
   */
  public void processDir(File dir)
    throws Exception 
  {
    // If the file we were passed was in fact a directory...
    if (dir.getAbsoluteFile().isDirectory()) 
    {
      // And it contains an index, optimize it.
      if (IndexReader.indexExists(dir.getAbsoluteFile()))
        makeDict(dir);

      else 
      {
        // Get the list of files it contains.
        String[] files = dir.getAbsoluteFile().list();

        // And process each of them.
        for (int i = 0; i < files.length; i++)
          processDir(new File(dir, files[i]));
      }

      return;
    } // if( dir.isDirectory() )

    // The current file is not a directory, so skip it.
  } // processDir()

  ////////////////////////////////////////////////////////////////////////////

  /**
   * Performs the actual work of creating a spelling dictionary.
   * <br><br>
   *
   * @param  mainIdxDir         The index database directory to scan. This
   *                            directory must contain a single Lucene index.
   *                            <br><br>
   *
   * @throws Exception          Passes back any exceptions generated by Lucene
   *                            during the dictionary generation process.
   *                            <br><br>
   */
  public void makeDict(File mainIdxDir)
    throws Exception 
  {
    // Detect if spelling data is present.
    String indexPath = Path.normalizePath(mainIdxDir.toString());
    String spellIdxPath = indexPath + "spellDict/";
    String wordQueuePath = spellIdxPath + "newWords.txt";
    String pairQueuePath = spellIdxPath + "newPairs.txt";
    if (new File(wordQueuePath).length() < 1 &&
        new File(pairQueuePath).length() < 1) 
    {
      return;
    }

    // Tell what index we're working on...
    String mainIdxPath = Path.normalizePath(mainIdxDir.toString());
    Trace.info("Index: [" + mainIdxPath + "] ... ");
    Trace.tab();
    Trace.tab(); // for phase

    SpellWriter spellWriter = null;

    try 
    {
      // Open the SpellWriter. We don't have to specify a stopword set for
      // this phase (it's only used during queuing.)
      //
      spellWriter = SpellWriter.open(new File(spellIdxPath));
      spellWriter.setMinWordFreq(3);

      // Perform the update.
      spellWriter.flushQueuedWords(new ProgressTracker() 
      {
        public void report(int pctDone, String descrip) {
          String pctTxt = Integer.toString(pctDone);
          while (pctTxt.length() < 3)
            pctTxt = " " + pctTxt;
          Trace.info("[" + pctTxt + "%] " + descrip);
        }
      });
    } //  try( to open the specified index )

    catch (Exception e) {
      Trace.error("*** Dictionary Creation Halted Due to Error:" + e);
      throw e;
    }
    finally {
      spellWriter.close();
    }

    Trace.untab(); // for phase
    Trace.untab();
    Trace.info("Done.");
  } // makeDict()
} // class IdxTreeDictMaker
